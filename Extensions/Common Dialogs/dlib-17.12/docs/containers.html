<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="verify-v1" content="02MiiaFNVzS5/u0eQhsy3/knioFHsia1X3DXRpHkE6I=">
<title>dlib C++ Library
               - Containers</title>
<script language="JavaScript">

            // ---------------------------------------------
            // --- Name:    Easy DHTML Treeview           --
            // --- Author:  D.D. de Kerf                  --
            // --- Version: 0.2          Date: 13-6-2001  --
            // ---------------------------------------------
            function Toggle(node)
            {
               // Unfold the branch if it isn't visible
               var next_node = node.nextSibling;
               if (next_node.style.display == 'none')
               {
                  // Change the image (if there is an image)
                  if (node.childNodes.length > 0)
                  {
                     if (node.childNodes.length > 0)
                     { 
                        if (node.childNodes.item(0).nodeName == "IMG")
                        {
                           node.childNodes.item(0).src = "minus.gif";
                        }
                     }
                  }

                  next_node.style.display = 'block';
               }
               // Collapse the branch if it IS visible
               else
               {
                  // Change the image (if there is an image)
                  if (node.childNodes.length > 0)
                  {
                     if (node.childNodes.length > 0)
                     { 
                        if (node.childNodes.item(0).nodeName == "IMG")
                        {
                           node.childNodes.item(0).src = "plus.gif";
                        }
                     }
                  }

                  next_node.style.display = 'none';
               }

            }
            </script><style type="text/css">
               body {margin:0px;}
               pre {margin:0px;}

               ul.tree  li { list-style: none;  margin-left:10px;} 
               ul.tree  { margin:0px; padding:0px; margin-left:5px;  }
               ul.tree  li ul { margin-left:10px; padding:0px; }

               div#component {
                  background-color:white; 
                  border: 2px solid rgb(102,102,102); 
                  text-align:left;
                  margin-top: 1.5em;
                  padding: 0.7em;
               }

               div#logb {
                  text-align:left;
                  padding: 0.0em;
                  float: left;
                  background-color:#c0c0c0; 
                  border: double ; 
                  margin: 0.5em;
               }

               .bdotted {border-bottom: 1px dotted}
               .bdashed {border-bottom: 1px dashed}
               .bsolid {border-bottom: 1px solid}
               .bdouble {border-bottom: 1px double}
               .bgroove {border-bottom: 1px groove}
               .bridge {border-bottom: 1px ridge}
               .binset {border-bottom: 1px inset}
               .boutset {border-bottom: 1px outset}

               div#row1 {
                  background-color:#dfdfdf; 
               }
               div#row2 {
                  background-color:#f2f2f2; 
               }

               div#typedefs {
                  margin-left: 1.5em;
                  margin-top: 0.2em;
                  border: 1px dotted;
                  width: 52em;
               }

               div#tdn {
                  width: 10em;
               }

               .fullhr {
                  clear: both;
               }

               body {
                  text-align: center;
               }

               div#entire_page {
                  width:62em;  
                  text-align: left;
                  margin-top: 0.4em;
                  margin-left: auto;
                  margin-right: auto;
               }
            </style>
</head>
<body bgcolor="#EDF3EE">
<a name="top"></a><div id="entire_page">
<table bgcolor="white" height="100%" bordercolor="#EDF3EE" CELLSPACING="0" CELLPADDING="10"><tr height="100%">
<td BGCOLOR="#E3E3E3" VALIGN="TOP" height="100%">
<br><table WIDTH="145" height="100%">
<tr>
<td VALIGN="TOP">
      <b>The Library</b><ul class="tree">
<li><a href="algorithms.html">Algorithms</a></li>
<li><a href="api.html">API Wrappers</a></li>
<li><a href="compression.html">Compression</a></li>
<li><a href="containers.html">Containers</a></li>
<li><a href="imaging.html">Imaging</a></li>
<li><a href="metaprogramming.html">Metaprogramming</a></li>
<li><a href="other.html">Miscellaneous</a></li>
<li><a href="network.html">Network</a></li>
<li><a href="parsing.html">Parsing</a></li>
</ul>
<br>
 

      <b>Help/Info</b><ul class="tree">
<li>
<a onclick="Toggle(this)" style="cursor: pointer;margin-left:-9px"><img src="plus.gif"><font color="green"><u>Examples</u></font></a><ul style="display:none;">
<li><a href="file_to_code_ex.cpp.html">Base64_Encoder</a></li>
<li><a href="bayes_net_ex.cpp.html">Bayesian_Network</a></li>
<li><a href="bayes_net_from_disk_ex.cpp.html">Bayesian_Network_From_Disk</a></li>
<li><a href="bayes_net_gui_ex.cpp.html">Bayesian_Network_GUI</a></li>
<li><a href="compress_stream_ex.cpp.html#_top">Cmd_Line_Parser</a></li>
<li><a href="compress_stream_ex.cpp.html">Compress_Stream</a></li>
<li><a href="dir_nav_ex.cpp.html">Directory_Navigation</a></li>
<li><a href="gui_api_ex.cpp.html">GUI</a></li>
<li><a href="server_http_ex.cpp.html">HTTP_Server</a></li>
<li><a href="image_ex.cpp.html">Image</a></li>
<li><a href="kcentroid_ex.cpp.html">Kernel_Centroid</a></li>
<li><a href="kkmeans_ex.cpp.html">Kernel_K-Means_Clustering</a></li>
<li><a href="krls_filter_ex.cpp.html">Kernel_RLS_Filtering</a></li>
<li><a href="krls_ex.cpp.html">Kernel_RLS_Regression</a></li>
<li><a href="logger_ex.cpp.html">Logger</a></li>
<li><a href="logger_ex_2.cpp.html">Logger_Advanced</a></li>
<li><a href="matrix_ex.cpp.html">Matrix</a></li>
<li><a href="member_function_pointer_ex.cpp.html">Member_Function_Pointer</a></li>
<li><a href="multithreaded_object_ex.cpp.html">Multithreaded_Object</a></li>
<li><a href="mlp_ex.cpp.html">Neural_Network</a></li>
<li><a href="pipe_ex.cpp.html">Pipe</a></li>
<li><a href="queue_ex.cpp.html">Queue</a></li>
<li><a href="rank_features_ex.cpp.html">Rank_Features</a></li>
<li><a href="rvm_ex.cpp.html">Relevance_Vector_Classification</a></li>
<li><a href="rvm_regression_ex.cpp.html">Relevance_Vector_Regression</a></li>
<li><a href="sockets_ex.cpp.html">Sockets</a></li>
<li><a href="sockets_ex_2.cpp.html">Sockets_2</a></li>
<li><a href="sockstreambuf_ex.cpp.html">Sockstreambuf</a></li>
<li><a href="std_allocator_ex.cpp.html">Std_C++_Allocator</a></li>
<li><a href="svm_ex.cpp.html">Support_Vector_Machine</a></li>
<li><a href="threaded_object_ex.cpp.html">Threaded_Object</a></li>
<li><a href="threads_ex.cpp.html">Threads</a></li>
<li><a href="thread_function_ex.cpp.html">Thread_Function</a></li>
<li><a href="thread_pool_ex.cpp.html">Thread_Pool</a></li>
<li><a href="timer_ex.cpp.html">Timer</a></li>
<li><a href="xml_parser_ex.cpp.html">XML_Parser</a></li>
</ul>
</li>
<li><a href="index.html">Home</a></li>
<li><a href="compile.html">How to compile</a></li>
<li><a href="term_index.html">Index</a></li>
<li><a href="intro.html">Introduction</a></li>
<li><a href="license.html">License</a></li>
</ul>
<br>
 
      <b>Current Release</b><ul class="tree">
<li><a href="change_log.html">Change Log</a></li>
<li><a href="release_notes.html">Release Notes</a></li>
<li>Version: 17.12</li>
</ul>
<br>


      
    </td>
<td width="1"></td>
</tr>
<tr><td valign="bottom">
      <br>
      <br>
      <br>
      <br>
      <br>
      <br>
      <br>
      <br>
      <br>
      
      Last Modified:<br>
      Nov 10, 2008
      <br>
      <br>
   </td></tr>
</table>
</td>
<td VALIGN="TOP" width="100%">
<center><h1>Containers</h1></center>
         <br><br>
         <p>
         Many of these containers were inspired by the RESOLVE/C++ course sequence at Ohio State.  As such, most of 
         the objects do not support copying in any form, only swapping is allowed. That is, when objects 
         are added or removed from any of these containers they are swapped in and out, not copied. 

         This allows you to do things like have containers of containers of containers without encountering the 
         overhead of the massive copying that would likely result if you did the same thing with the STL.
         </p>

         <p>
         To use any of these containers all you need to do is #include the file indicated in the 
         short section about the component you would like to use. Then pick which implementation you 
         would like and typedef it to something nice. Here is an example of creating a typedef for 
         a set of integers using the first kernel implementation. <br>
         <tt>typedef dlib::set&lt;int&gt;::kernel_1a set_of_ints;</tt> 
         </p>


         <p>
         Note that it is assumed by these containers that swap() and operator&lt; do not throw.  They
         may not function correctly if this assumption is broken.  Also note that the built in types (int, long,
         char, etc...) and std::string will not cause operator&lt; or swap() to throw.
         </p>

         <p>
            Note also that most of the containers inherit from the <a href="#enumerable">enumerable</a>
            interface.  Thus, all the member functions inherited from enumerable are defined
            in the enumerable class and their documentation is not repeated in each 
            container's documentation.  This includes the size() member function in each
            container.
         </p>

   
   </td>
<td BGCOLOR="#E3E3E3" VALIGN="TOP" height="100%">
<br><table WIDTH="150" height="100%">
<tr>
<td VALIGN="TOP">
      <b>Objects</b><ul class="tree">
<li><a href="#array">array</a></li>
<li><a href="#array2d">array2d</a></li>
<li><a href="#binary_search_tree">binary_search_tree</a></li>
<li><a href="#directed_graph">directed_graph</a></li>
<li><a href="#graph">graph</a></li>
<li><a href="#hash_map">hash_map</a></li>
<li><a href="#hash_set">hash_set</a></li>
<li><a href="#hash_table">hash_table</a></li>
<li><a href="#map">map</a></li>
<li><a href="#matrix">matrix</a></li>
<li><a href="#queue">queue</a></li>
<li><a href="#reference_counter">reference_counter</a></li>
<li><a href="#sequence">sequence</a></li>
<li><a href="#set">set</a></li>
<li><a href="#sliding_buffer">sliding_buffer</a></li>
<li>
<a onclick="Toggle(this)" style="cursor: pointer;margin-left:-9px"><img src="plus.gif"><font color="green"><u>smart pointers</u></font></a><ul style="display:none;">
<li><a href="#scoped_ptr">scoped_ptr</a></li>
<li><a href="#shared_ptr">shared_ptr</a></li>
<li><a href="#shared_ptr_thread_safe">shared_ptr_thread_safe</a></li>
<li><a href="#weak_ptr">weak_ptr</a></li>
</ul>
</li>
<li><a href="#stack">stack</a></li>
<li><a href="#static_map">static_map</a></li>
<li><a href="#static_set">static_set</a></li>
<li><a href="#std_vector_c">std_vector_c</a></li>
<li><a href="#tuple">tuple</a></li>
</ul>
<br>

      <b>Interfaces</b><ul class="tree">
<li><a href="#enumerable">enumerable</a></li>
<li><a href="#map_pair">map_pair</a></li>
<li>
<a href="#remover" style="float:right"><img src="down.gif" border="0"></a><a onclick="Toggle(this)" style="cursor: pointer;"><img src="plus.gif" border="0"><font color="green"><u>remover</u></font></a><ul style="display:none;">
<li><a href="dlib/interfaces/remover.h.html#asc_pair_remover">asc_pair_remover</a></li>
<li><a href="dlib/interfaces/remover.h.html#asc_remover">asc_remover</a></li>
<li><a href="dlib/interfaces/remover.h.html#pair_remover">pair_remover</a></li>
<li><a href="dlib/interfaces/remover.h.html#remover">remover</a></li>
</ul>
</li>
</ul>
<br>     
    </td>
<td width="1"></td>
</tr>
<tr><td valign="bottom"></td></tr>
</table>
</td>
</tr></table>
<a name="array"><div id="component">
<a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">array</h1>
<BR><BR>
            This object is just like a C style array and the accessor functions operate 
            in constant time. 
         <BR><BR><b>Specification: </b><a href="dlib/array/array_kernel_abstract.h.html">dlib/array/array_kernel_abstract.h</a><BR><B>File to include: </B><a href="dlib/array.h.html">dlib/array.h</a><BR><BR><B>Implementations:</B><blockquote>
<a href="dlib/array/array_kernel_1.h.html">array_kernel_1</a>:
                  <br> 
                  This implementation is done using an array of pointers, each of which point to 
                  small sections of the array. This implementation allows the array to use only 
                  about as much memory as it needs at any given time.
                  It does not use the <a href="other.html#memory_manager">memory_manager</a> at all. 

               <div id="typedefs"><table CELLSPACING="0" CELLPADDING="0" bgcolor="white">
<tr>
<td bgcolor="#E3E3E3" valign="top"><div id="tdn">kernel_1a</div></td>
<td width="100%" bgcolor="#E3E3E3">is a typedef for array_kernel_1</td>
</tr>
<tr>
<td valign="top"><div id="tdn">kernel_1a_c</div></td>
<td width="100%"> 
                  is a typedef for kernel_1a that checks its preconditions.             
                  </td>
</tr>
</table></div>
</blockquote>
<blockquote>
<a href="dlib/array/array_kernel_2.h.html">array_kernel_2</a>:
                  <br> 
                  This implementation is done using a single array of max_size() elements.  So this
                  is just a simple layer on top of a C style array.
                  It uses the <a href="other.html#memory_manager">memory_manager</a> for all 
                  memory allocations. 

               <div id="typedefs"><table CELLSPACING="0" CELLPADDING="0" bgcolor="white">
<tr>
<td bgcolor="#E3E3E3" valign="top"><div id="tdn">kernel_2a</div></td>
<td width="100%" bgcolor="#E3E3E3">is a typedef for array_kernel_2</td>
</tr>
<tr>
<td valign="top"><div id="tdn">kernel_2a_c</div></td>
<td width="100%"> 
                  is a typedef for kernel_2a that checks its preconditions.             
                  </td>
</tr>
</table></div>
</blockquote>
<center>
<HR align="center">
<h2>Extensions to array</h2>
</center>
<BR><a name="array_expand"><B><font size="4">array_expand:</font></B></a><Br> 
                This extension gives an array the ability to expand its size() beyond
                its max_size() without clearing out all its elements.  It also adds a set of pop/push_back()
                functions similar to the ones in the std::vector object.
               <BR><BR><b>Specification: </b><a href="dlib/array/array_expand_abstract.h.html">dlib/array/array_expand_abstract.h</a><BR><BR><B>Implementations:</B><blockquote>
<a href="dlib/array/array_expand_1.h.html">array_expand_1</a>:
                  <br> 
                        This is implemented by creating a new bigger array if max_size() isn't big enough,
                        swapping everything into that new array, and then swapping that array with *this.
                     <div id="typedefs"><table CELLSPACING="0" CELLPADDING="0" bgcolor="white">
<tr>
<td bgcolor="#E3E3E3" valign="top"><div id="tdn">expand_1a</div></td>
<td width="100%" bgcolor="#E3E3E3">is a typedef for array_sort_1a extended by array_expand_1</td>
</tr>
<tr>
<td valign="top"><div id="tdn">expand_1a_c</div></td>
<td width="100%"> 
                  is a typedef for expand_1a that checks its preconditions.             
                  </td>
</tr>
<tr>
<td bgcolor="#E3E3E3" valign="top"><div id="tdn">expand_1b</div></td>
<td width="100%" bgcolor="#E3E3E3">is a typedef for array_sort_1b extended by array_expand_1</td>
</tr>
<tr>
<td valign="top"><div id="tdn">expand_1b_c</div></td>
<td width="100%"> 
                  is a typedef for expand_1b that checks its preconditions.             
                  </td>
</tr>
<tr>
<td bgcolor="#E3E3E3" valign="top"><div id="tdn">expand_1c</div></td>
<td width="100%" bgcolor="#E3E3E3">is a typedef for array_sort_2a extended by array_expand_1</td>
</tr>
<tr>
<td valign="top"><div id="tdn">expand_1c_c</div></td>
<td width="100%"> 
                  is a typedef for expand_1c that checks its preconditions.             
                  </td>
</tr>
<tr>
<td bgcolor="#E3E3E3" valign="top"><div id="tdn">expand_1d</div></td>
<td width="100%" bgcolor="#E3E3E3">is a typedef for array_sort_2b extended by array_expand_1</td>
</tr>
<tr>
<td valign="top"><div id="tdn">expand_1d_c</div></td>
<td width="100%"> 
                  is a typedef for expand_1d that checks its preconditions.             
                  </td>
</tr>
</table></div>
</blockquote>
<HR width="20%" align="left">
<BR><a name="array_sort"><B><font size="4">array_sort:</font></B></a><Br> 
                  This extension gives an array the ability to sort its contents.
               <BR><BR><b>Specification: </b><a href="dlib/array/array_sort_abstract.h.html">dlib/array/array_sort_abstract.h</a><BR><BR><B>Implementations:</B><blockquote>
<a href="dlib/array/array_sort_1.h.html">array_sort_1</a>:
                  <br> 
                        This is a version of the QuickSort algorithm. It swaps the entire array into a C 
                        style array, sorts it and then swaps it back into the array object.
                     <div id="typedefs"><table CELLSPACING="0" CELLPADDING="0" bgcolor="white">
<tr>
<td bgcolor="#E3E3E3" valign="top"><div id="tdn">sort_1a</div></td>
<td width="100%" bgcolor="#E3E3E3">is a typedef for array_kernel_1a extended by array_sort_1</td>
</tr>
<tr>
<td valign="top"><div id="tdn">sort_1a_c</div></td>
<td width="100%"> 
                  is a typedef for sort_1a that checks its preconditions.             
                  </td>
</tr>
<tr>
<td bgcolor="#E3E3E3" valign="top"><div id="tdn">sort_1b</div></td>
<td width="100%" bgcolor="#E3E3E3">is a typedef for array_kernel_2a extended by array_sort_1</td>
</tr>
<tr>
<td valign="top"><div id="tdn">sort_1b_c</div></td>
<td width="100%"> 
                  is a typedef for sort_1b that checks its preconditions.             
                  </td>
</tr>
</table></div>
</blockquote>
<blockquote>
<a href="dlib/array/array_sort_2.h.html">array_sort_2</a>:
                  <br> 
                        This is a version of the QuickSort algorithm.
                     <div id="typedefs"><table CELLSPACING="0" CELLPADDING="0" bgcolor="white">
<tr>
<td bgcolor="#E3E3E3" valign="top"><div id="tdn">sort_2a</div></td>
<td width="100%" bgcolor="#E3E3E3">is a typedef for array_kernel_1a extended by array_sort_2</td>
</tr>
<tr>
<td valign="top"><div id="tdn">sort_2a_c</div></td>
<td width="100%"> 
                  is a typedef for sort_2a that checks its preconditions.             
                  </td>
</tr>
<tr>
<td bgcolor="#E3E3E3" valign="top"><div id="tdn">sort_2b</div></td>
<td width="100%" bgcolor="#E3E3E3">is a typedef for array_kernel_2a extended by array_sort_2</td>
</tr>
<tr>
<td valign="top"><div id="tdn">sort_2b_c</div></td>
<td width="100%"> 
                  is a typedef for sort_2b that checks its preconditions.             
                  </td>
</tr>
</table></div>
</blockquote>
<center></center>
</div></a><a name="array2d"><div id="component">
<a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">array2d</h1>
<BR><BR>
                This object represents a 2-Dimensional array of objects.
         <BR><BR><b>Specification: </b><a href="dlib/array2d/array2d_kernel_abstract.h.html">dlib/array2d/array2d_kernel_abstract.h</a><BR><B>File to include: </B><a href="dlib/array2d.h.html">dlib/array2d.h</a><BR><b>Code Examples: </b><a href="image_ex.cpp.html">1</a><BR><BR><B>Implementations:</B><blockquote>
<a href="dlib/array2d/array2d_kernel_1.h.html">array2d_kernel_1</a>:
                  <br> 
                  This is implemented in the obvious way.  See the source for details.
                  It uses the <a href="other.html#memory_manager">memory_manager</a> for all memory allocations.
               <div id="typedefs"><table CELLSPACING="0" CELLPADDING="0" bgcolor="white">
<tr>
<td bgcolor="#E3E3E3" valign="top"><div id="tdn">kernel_1a</div></td>
<td width="100%" bgcolor="#E3E3E3">is a typedef for array2d_kernel_1</td>
</tr>
<tr>
<td valign="top"><div id="tdn">kernel_1a_c</div></td>
<td width="100%"> 
                  is a typedef for kernel_1a that checks its preconditions.             
                  </td>
</tr>
</table></div>
</blockquote>
<center></center>
</div></a><a name="binary_search_tree"><div id="component">
<a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">binary_search_tree</h1>
<BR><BR>
            This object represents a data dictionary that is built on top of some kind of binary search tree.  
         <BR><BR><b>Specification: </b><a href="dlib/binary_search_tree/binary_search_tree_kernel_abstract.h.html">dlib/binary_search_tree/binary_search_tree_kernel_abstract.h</a><BR><B>File to include: </B><a href="dlib/binary_search_tree.h.html">dlib/binary_search_tree.h</a><BR><BR><B>Implementations:</B><blockquote>
<a href="dlib/binary_search_tree/binary_search_tree_kernel_1.h.html">binary_search_tree_kernel_1</a>:
                  <br> 
        This implementation is done using an AVL binary search tree.  It uses the 
        <a href="other.html#memory_manager">memory_manager</a> for all memory allocations.
     <div id="typedefs"><table CELLSPACING="0" CELLPADDING="0" bgcolor="white">
<tr>
<td bgcolor="#E3E3E3" valign="top"><div id="tdn">kernel_1a</div></td>
<td width="100%" bgcolor="#E3E3E3">is a typedef for binary_search_tree_kernel_1</td>
</tr>
<tr>
<td valign="top"><div id="tdn">kernel_1a_c</div></td>
<td width="100%"> 
                  is a typedef for kernel_1a that checks its preconditions.             
                  </td>
</tr>
</table></div>
</blockquote>
<blockquote>
<a href="dlib/binary_search_tree/binary_search_tree_kernel_2.h.html">binary_search_tree_kernel_2</a>:
                  <br> 
                  This implementation is done using a red-black binary search tree.  It uses the 
        <a href="other.html#memory_manager">memory_manager</a> for all memory allocations. 
               <div id="typedefs"><table CELLSPACING="0" CELLPADDING="0" bgcolor="white">
<tr>
<td bgcolor="#E3E3E3" valign="top"><div id="tdn">kernel_2a</div></td>
<td width="100%" bgcolor="#E3E3E3">is a typedef for binary_search_tree_kernel_2</td>
</tr>
<tr>
<td valign="top"><div id="tdn">kernel_2a_c</div></td>
<td width="100%"> 
                  is a typedef for kernel_2a that checks its preconditions.             
                  </td>
</tr>
</table></div>
</blockquote>
<center></center>
</div></a><a name="directed_graph"><div id="component">
<a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">directed_graph</h1>
<BR><BR>
                This object represents a directed graph which is a set of nodes with directed
                edges connecting various nodes.  
         <BR><BR><b>Specification: </b><a href="dlib/directed_graph/directed_graph_kernel_abstract.h.html">dlib/directed_graph/directed_graph_kernel_abstract.h</a><BR><B>File to include: </B><a href="dlib/directed_graph.h.html">dlib/directed_graph.h</a><BR><BR><B>Implementations:</B><blockquote>
<a href="dlib/directed_graph/directed_graph_kernel_1.h.html">directed_graph_kernel_1</a>:
                  <br> 
                  This is implemented using std::vector to contain all the nodes and edges.   
               <div id="typedefs"><table CELLSPACING="0" CELLPADDING="0" bgcolor="white">
<tr>
<td bgcolor="#E3E3E3" valign="top"><div id="tdn">kernel_1a</div></td>
<td width="100%" bgcolor="#E3E3E3">is a typedef for directed_graph_kernel_1</td>
</tr>
<tr>
<td valign="top"><div id="tdn">kernel_1a_c</div></td>
<td width="100%"> 
                  is a typedef for kernel_1a that checks its preconditions.             
                  </td>
</tr>
</table></div>
</blockquote>
<center></center>
</div></a><a name="enumerable"><div id="component">
<a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">enumerable</h1>
<BR><BR>
            This object is an abstract class which represents an interface for iterating over 
            all the elements of a container. 
         <BR><BR><b>Specification: </b><a href="dlib/interfaces/enumerable.h.html">dlib/interfaces/enumerable.h</a><BR><B>File to include: </B><a href="dlib/interfaces/enumerable.h.html">dlib/interfaces/enumerable.h</a><br><br><center></center>
</div></a><a name="graph"><div id="component">
<a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">graph</h1>
<BR><BR>
                This object represents a graph which is a set of nodes with undirected
                edges connecting various nodes.  
         <BR><BR><b>Specification: </b><a href="dlib/graph/graph_kernel_abstract.h.html">dlib/graph/graph_kernel_abstract.h</a><BR><B>File to include: </B><a href="dlib/graph.h.html">dlib/graph.h</a><BR><BR><B>Implementations:</B><blockquote>
<a href="dlib/graph/graph_kernel_1.h.html">graph_kernel_1</a>:
                  <br> 
                  This is implemented using std::vector to contain all the nodes and edges.   
               <div id="typedefs"><table CELLSPACING="0" CELLPADDING="0" bgcolor="white">
<tr>
<td bgcolor="#E3E3E3" valign="top"><div id="tdn">kernel_1a</div></td>
<td width="100%" bgcolor="#E3E3E3">is a typedef for graph_kernel_1</td>
</tr>
<tr>
<td valign="top"><div id="tdn">kernel_1a_c</div></td>
<td width="100%"> 
                  is a typedef for kernel_1a that checks its preconditions.             
                  </td>
</tr>
</table></div>
</blockquote>
<center></center>
</div></a><a name="hash_map"><div id="component">
<a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">hash_map</h1>
<BR><BR>
            This object represents a hashed mapping of items of type domain onto items of type range. 
         <BR><BR><b>Specification: </b><a href="dlib/hash_map/hash_map_kernel_abstract.h.html">dlib/hash_map/hash_map_kernel_abstract.h</a><BR><B>File to include: </B><a href="dlib/hash_map.h.html">dlib/hash_map.h</a><BR><BR><B>Implementations:</B><blockquote>
<a href="dlib/hash_map/hash_map_kernel_1.h.html">hash_map_kernel_1</a>:
                  <br> 
                  This implementation is done using a <a href="#hash_table">hash_table</a> object. It uses the 
        <a href="other.html#memory_manager">memory_manager</a> for all memory allocations.

               <div id="typedefs"><table CELLSPACING="0" CELLPADDING="0" bgcolor="white">
<tr>
<td bgcolor="#E3E3E3" valign="top"><div id="tdn">kernel_1a</div></td>
<td width="100%" bgcolor="#E3E3E3">is a typedef for hash_map_kernel_1 that uses hash_table_kernel_1a</td>
</tr>
<tr>
<td valign="top"><div id="tdn">kernel_1a_c</div></td>
<td width="100%"> 
                  is a typedef for kernel_1a that checks its preconditions.             
                  </td>
</tr>
<tr>
<td bgcolor="#E3E3E3" valign="top"><div id="tdn">kernel_1b</div></td>
<td width="100%" bgcolor="#E3E3E3">is a typedef for hash_map_kernel_1 that uses hash_table_kernel_2a</td>
</tr>
<tr>
<td valign="top"><div id="tdn">kernel_1b_c</div></td>
<td width="100%"> 
                  is a typedef for kernel_1b that checks its preconditions.             
                  </td>
</tr>
<tr>
<td bgcolor="#E3E3E3" valign="top"><div id="tdn">kernel_1c</div></td>
<td width="100%" bgcolor="#E3E3E3">is a typedef for hash_map_kernel_1 that uses hash_table_kernel_2b</td>
</tr>
<tr>
<td valign="top"><div id="tdn">kernel_1c_c</div></td>
<td width="100%"> 
                  is a typedef for kernel_1c that checks its preconditions.             
                  </td>
</tr>
</table></div>
</blockquote>
<center></center>
</div></a><a name="hash_set"><div id="component">
<a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">hash_set</h1>
<BR><BR>
            This object represents a hashed unordered and unaddressed collection of unique items. 
         <BR><BR><b>Specification: </b><a href="dlib/hash_set/hash_set_kernel_abstract.h.html">dlib/hash_set/hash_set_kernel_abstract.h</a><BR><B>File to include: </B><a href="dlib/hash_set.h.html">dlib/hash_set.h</a><BR><BR><B>Implementations:</B><blockquote>
<a href="dlib/hash_set/hash_set_kernel_1.h.html">hash_set_kernel_1</a>:
                  <br> 
                  This implementation is done using a <a href="#hash_table">hash_table</a> object. It uses the 
        <a href="other.html#memory_manager">memory_manager</a> for all memory allocations.

               <div id="typedefs"><table CELLSPACING="0" CELLPADDING="0" bgcolor="white">
<tr>
<td bgcolor="#E3E3E3" valign="top"><div id="tdn">kernel_1a</div></td>
<td width="100%" bgcolor="#E3E3E3">is a typedef for hash_set_kernel_1 that uses hash_table_kernel_1a</td>
</tr>
<tr>
<td valign="top"><div id="tdn">kernel_1a_c</div></td>
<td width="100%"> 
                  is a typedef for kernel_1a that checks its preconditions.             
                  </td>
</tr>
<tr>
<td bgcolor="#E3E3E3" valign="top"><div id="tdn">kernel_1b</div></td>
<td width="100%" bgcolor="#E3E3E3">is a typedef for hash_set_kernel_1 that uses hash_table_kernel_2a</td>
</tr>
<tr>
<td valign="top"><div id="tdn">kernel_1b_c</div></td>
<td width="100%"> 
                  is a typedef for kernel_1b that checks its preconditions.             
                  </td>
</tr>
<tr>
<td bgcolor="#E3E3E3" valign="top"><div id="tdn">kernel_1c</div></td>
<td width="100%" bgcolor="#E3E3E3">is a typedef for hash_set_kernel_1 that uses hash_table_kernel_2b</td>
</tr>
<tr>
<td valign="top"><div id="tdn">kernel_1c_c</div></td>
<td width="100%"> 
                  is a typedef for kernel_1c that checks its preconditions.             
                  </td>
</tr>
</table></div>
</blockquote>
<center></center>
</div></a><a name="hash_table"><div id="component">
<a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">hash_table</h1>
<BR><BR>
            This object represents a data dictionary that is built on top of some kind of 
            hash table. 
         <BR><BR><b>Specification: </b><a href="dlib/hash_table/hash_table_kernel_abstract.h.html">dlib/hash_table/hash_table_kernel_abstract.h</a><BR><B>File to include: </B><a href="dlib/hash_table.h.html">dlib/hash_table.h</a><BR><BR><B>Implementations:</B><blockquote>
<a href="dlib/hash_table/hash_table_kernel_1.h.html">hash_table_kernel_1</a>:
                  <br> 
                  This implementation is done using singly linked lists as hashing buckets.  It uses the 
        <a href="other.html#memory_manager">memory_manager</a> for all memory allocations. 
               <div id="typedefs"><table CELLSPACING="0" CELLPADDING="0" bgcolor="white">
<tr>
<td bgcolor="#E3E3E3" valign="top"><div id="tdn">kernel_1a</div></td>
<td width="100%" bgcolor="#E3E3E3">is a typedef for hash_table_kernel_1. </td>
</tr>
<tr>
<td valign="top"><div id="tdn">kernel_1a_c</div></td>
<td width="100%"> 
                  is a typedef for kernel_1a that checks its preconditions.             
                  </td>
</tr>
</table></div>
</blockquote>
<blockquote>
<a href="dlib/hash_table/hash_table_kernel_2.h.html">hash_table_kernel_2</a>:
                  <br> 
                  This implementation is done using <a href="#binary_search_tree">
                  binary_search_tree</a> objects as hashing buckets.  It uses the 
        <a href="other.html#memory_manager">memory_manager</a> for all memory allocations. 

               <div id="typedefs"><table CELLSPACING="0" CELLPADDING="0" bgcolor="white">
<tr>
<td bgcolor="#E3E3E3" valign="top"><div id="tdn">kernel_2a</div></td>
<td width="100%" bgcolor="#E3E3E3">is a typedef for hash_table_kernel_2 that uses binary_search_tree_kernel_1</td>
</tr>
<tr>
<td valign="top"><div id="tdn">kernel_2a_c</div></td>
<td width="100%"> 
                  is a typedef for kernel_2a that checks its preconditions.             
                  </td>
</tr>
<tr>
<td bgcolor="#E3E3E3" valign="top"><div id="tdn">kernel_2b</div></td>
<td width="100%" bgcolor="#E3E3E3">is a typedef for hash_table_kernel_2 that uses binary_search_tree_kernel_2</td>
</tr>
<tr>
<td valign="top"><div id="tdn">kernel_2b_c</div></td>
<td width="100%"> 
                  is a typedef for kernel_2b that checks its preconditions.             
                  </td>
</tr>
</table></div>
</blockquote>
<center></center>
</div></a><a name="map"><div id="component">
<a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">map</h1>
<BR><BR>
            This object represents a mapping of items of type domain onto items of type range.
         <BR><BR><b>Specification: </b><a href="dlib/map/map_kernel_abstract.h.html">dlib/map/map_kernel_abstract.h</a><BR><B>File to include: </B><a href="dlib/map.h.html">dlib/map.h</a><BR><BR><B>Implementations:</B><blockquote>
<a href="dlib/map/map_kernel_1.h.html">map_kernel_1</a>:
                  <br> 
                  This is implemented using the <a href="#binary_search_tree">binary_search_tree</a> component. It uses the 
        <a href="other.html#memory_manager">memory_manager</a> for all memory allocations.

               <div id="typedefs"><table CELLSPACING="0" CELLPADDING="0" bgcolor="white">
<tr>
<td bgcolor="#E3E3E3" valign="top"><div id="tdn">kernel_1a</div></td>
<td width="100%" bgcolor="#E3E3E3">is a typedef for map_kernel_1 that uses binary_search_tree_kernel_1</td>
</tr>
<tr>
<td valign="top"><div id="tdn">kernel_1a_c</div></td>
<td width="100%"> 
                  is a typedef for kernel_1a that checks its preconditions.             
                  </td>
</tr>
<tr>
<td bgcolor="#E3E3E3" valign="top"><div id="tdn">kernel_1b</div></td>
<td width="100%" bgcolor="#E3E3E3">is a typedef for map_kernel_1 that uses binary_search_tree_kernel_2</td>
</tr>
<tr>
<td valign="top"><div id="tdn">kernel_1b_c</div></td>
<td width="100%"> 
                  is a typedef for kernel_1b that checks its preconditions.             
                  </td>
</tr>
</table></div>
</blockquote>
<center></center>
</div></a><a name="map_pair"><div id="component">
<a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">map_pair</h1>
<BR><BR>
            This object is an abstract class which represents an interface for accessing a 
            pair from a container such as the map, hash_table, etc... 
         <BR><BR><b>Specification: </b><a href="dlib/interfaces/map_pair.h.html">dlib/interfaces/map_pair.h</a><BR><B>File to include: </B><a href="dlib/interfaces/map_pair.h.html">dlib/interfaces/map_pair.h</a><br><br><center></center>
</div></a><a name="matrix"><div id="component">
<a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">matrix</h1>
<BR><BR>
           This is a 2D matrix object.  It is implemented using the expression templates 
           technique which allows us to eliminate the temporary matrix objects that would 
           normally be returned from expressions such as M = A+B+C+D;  Normally each 
           invocation of the + operator would construct and return a temporary matrix 
           object but using this technique we can avoid creating all of these temporary 
           objects and receive a large speed boost.
         <p>
            Note that there is only one implementation of this object so there aren't any
            different kernels to choose from when you create instances of the matrix object.  
            So for example, you
            could declare a matrix of 2 rows and 3 columns using the following statement: 
            <tt>dlib::matrix&lt;float,2,3&gt; m;</tt>  
         </p>
         <p>
            It should also be noted that matrix multiplication is fastest when the two matrices
            being multiplied are not complex matrix_exp objects returned from other expressions 
            (such as other matrix multiplies).  This is because the matrix multiply operator will
            evaluate each element of the matrices it is multiplying many times, and a matrix_exp
            computes its elements' values each time they are queried.  However, the matrix multiply 
            operator is the only one that evaluates its argument's elements multiple times so you can
            stack up all the other operators however you want without any performance penalty.  If
            you want to multiply two complex matrix_exp expressions together you can easily convert them into
            fully evaluated temporary matrix objects by using the tmp() function.  For example, to
            multiply four matrices together you should use an expression such as <tt>result = tmp(a*b)*tmp(c*d);</tt>
         </p>
         <BR><BR><b>Specification: </b><a href="dlib/matrix/matrix_abstract.h.html#matrix">dlib/matrix/matrix_abstract.h</a><BR><B>File to include: </B><a href="dlib/matrix.h.html">dlib/matrix.h</a><BR><b>Code Examples: </b><a href="matrix_ex.cpp.html">1</a><br><br><center>
<HR align="center">
<h2>Extensions to matrix</h2>
</center>
<BR><a name="matrix_math_functions"><B><font size="4">matrix_math_functions:</font></B></a><Br>This extension contains mathematical functions that operate on each
                  element of a matrix independently.  Note that you don't need to #include
                  anything to get them.  They are included by the <a href="dlib/matrix.h.html">dlib/matrix.h</a> file for you.
               <BR><BR><b>Specification: </b><a href="dlib/matrix/matrix_math_functions_abstract.h.html">dlib/matrix/matrix_math_functions_abstract.h</a><HR width="20%" align="left">
<BR><a name="matrix_utilities"><B><font size="4">matrix_utilities:</font></B></a><Br>This extension contains miscellaneous utility functions
                  for manipulating matrix objects.  Note that you don't need to #include
                  anything to get them.  They are included by the <a href="dlib/matrix.h.html">dlib/matrix.h</a> file for you.
               <BR><BR><b>Specification: </b><a href="dlib/matrix/matrix_utilities_abstract.h.html">dlib/matrix/matrix_utilities_abstract.h</a><center></center>
</div></a><a name="queue"><div id="component">
<a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">queue</h1>
<BR><BR>
            This object represents a first in first out queue. 
         <BR><BR><b>Specification: </b><a href="dlib/queue/queue_kernel_abstract.h.html">dlib/queue/queue_kernel_abstract.h</a><BR><B>File to include: </B><a href="dlib/queue.h.html">dlib/queue.h</a><BR><b>Code Examples: </b><a href="queue_ex.cpp.html">1</a><BR><BR><B>Implementations:</B><blockquote>
<a href="dlib/queue/queue_kernel_1.h.html">queue_kernel_1</a>:
                  <br> 
                  This is implemented in the obvious way using a singly linked list.  It does not use the 
        <a href="other.html#memory_manager">memory_manager</a> at all. 
               <div id="typedefs"><table CELLSPACING="0" CELLPADDING="0" bgcolor="white">
<tr>
<td bgcolor="#E3E3E3" valign="top"><div id="tdn">kernel_1a</div></td>
<td width="100%" bgcolor="#E3E3E3">is a typedef for queue_kernel_1</td>
</tr>
<tr>
<td valign="top"><div id="tdn">kernel_1a_c</div></td>
<td width="100%"> 
                  is a typedef for kernel_1a that checks its preconditions.             
                  </td>
</tr>
</table></div>
</blockquote>
<blockquote>
<a href="dlib/queue/queue_kernel_2.h.html">queue_kernel_2</a>:
                  <br> 
               This is implemented using a singly linked list and each node in the list
               contains block_size (a template parameter) elements.  It uses the 
        <a href="other.html#memory_manager">memory_manager</a> for all memory allocations. 
               <div id="typedefs"><table CELLSPACING="0" CELLPADDING="0" bgcolor="white">
<tr>
<td bgcolor="#E3E3E3" valign="top"><div id="tdn">kernel_2a</div></td>
<td width="100%" bgcolor="#E3E3E3">is a typedef for queue_kernel_2 with a block_size of 20</td>
</tr>
<tr>
<td valign="top"><div id="tdn">kernel_2a_c</div></td>
<td width="100%"> 
                  is a typedef for kernel_2a that checks its preconditions.             
                  </td>
</tr>
<tr>
<td bgcolor="#E3E3E3" valign="top"><div id="tdn">kernel_2b</div></td>
<td width="100%" bgcolor="#E3E3E3">is a typedef for queue_kernel_2 with a block_size of 100</td>
</tr>
<tr>
<td valign="top"><div id="tdn">kernel_2b_c</div></td>
<td width="100%"> 
                  is a typedef for kernel_2b that checks its preconditions.             
                  </td>
</tr>
</table></div>
</blockquote>
<center>
<HR align="center">
<h2>Extensions to queue</h2>
</center>
<BR><a name="queue_sort"><B><font size="4">queue_sort:</font></B></a><Br> 
                  This extension gives a queue the ability to sort its contents.
               <BR><BR><b>Specification: </b><a href="dlib/queue/queue_sort_abstract.h.html">dlib/queue/queue_sort_abstract.h</a><BR><BR><B>Implementations:</B><blockquote>
<a href="dlib/queue/queue_sort_1.h.html">queue_sort_1</a>:
                  <br> 
                        This is a version of the QuickSort algorithm.
                     <div id="typedefs"><table CELLSPACING="0" CELLPADDING="0" bgcolor="white">
<tr>
<td bgcolor="#E3E3E3" valign="top"><div id="tdn">sort_1a</div></td>
<td width="100%" bgcolor="#E3E3E3">is a typedef for queue_kernel_1a extended by queue_sort_1</td>
</tr>
<tr>
<td valign="top"><div id="tdn">sort_1a_c</div></td>
<td width="100%"> 
                  is a typedef for sort_1a that checks its preconditions.             
                  </td>
</tr>
<tr>
<td bgcolor="#E3E3E3" valign="top"><div id="tdn">sort_1b</div></td>
<td width="100%" bgcolor="#E3E3E3">is a typedef for queue_kernel_2a extended by queue_sort_1</td>
</tr>
<tr>
<td valign="top"><div id="tdn">sort_1b_c</div></td>
<td width="100%"> 
                  is a typedef for sort_1b that checks its preconditions.             
                  </td>
</tr>
<tr>
<td bgcolor="#E3E3E3" valign="top"><div id="tdn">sort_1c</div></td>
<td width="100%" bgcolor="#E3E3E3">is a typedef for queue_kernel_2b extended by queue_sort_1</td>
</tr>
<tr>
<td valign="top"><div id="tdn">sort_1c_c</div></td>
<td width="100%"> 
                  is a typedef for sort_1c that checks its preconditions.             
                  </td>
</tr>
</table></div>
</blockquote>
<center></center>
</div></a><a name="reference_counter"><div id="component">
<a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">reference_counter</h1>
<BR><BR>
            This object represents a container for an object and provides reference counting
            capabilities for the object it contains. 
         <BR><BR><b>Specification: </b><a href="dlib/reference_counter/reference_counter_kernel_abstract.h.html">dlib/reference_counter/reference_counter_kernel_abstract.h</a><BR><B>File to include: </B><a href="dlib/reference_counter.h.html">dlib/reference_counter.h</a><BR><BR><B>Implementations:</B><blockquote>
<a href="dlib/reference_counter/reference_counter_kernel_1.h.html">reference_counter_kernel_1</a>:
                  <br> 
                  This implementation is done using pointers in the obvious way.
               <div id="typedefs"><table CELLSPACING="0" CELLPADDING="0" bgcolor="white"><tr>
<td bgcolor="#E3E3E3" valign="top"><div id="tdn">kernel_1a</div></td>
<td width="100%" bgcolor="#E3E3E3">is a typedef for reference_counter_kernel_1</td>
</tr></table></div>
</blockquote>
<center></center>
</div></a><a name="remover"><div id="component">
<a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">remover</h1>
<BR><BR>
            This is a set of interfaces which gives the ability to remove all the items in a 
            container without actually knowing what kind of container contains them. 
         <BR><BR><b>Specification: </b><a href="dlib/interfaces/remover.h.html">dlib/interfaces/remover.h</a><BR><B>File to include: </B><a href="dlib/interfaces/remover.h.html">dlib/interfaces/remover.h</a><br><br><center></center>
</div></a><a name="scoped_ptr"><div id="component">
<a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">scoped_ptr</h1>
<BR><BR>
                This is a implementation of the scoped_ptr class found in the Boost C++ 
                library.  It is a simple smart pointer class which guarantees that the 
                pointer contained within it will always be deleted.  
                
                The class does not permit copying and so does not do any kind of 
                reference counting.  Thus it is very simple and quite fast.
         <BR><BR><b>Specification: </b><a href="dlib/smart_pointers/scoped_ptr_abstract.h.html">dlib/smart_pointers/scoped_ptr_abstract.h</a><BR><B>File to include: </B><a href="dlib/smart_pointers.h.html">dlib/smart_pointers.h</a><br><br><center></center>
</div></a><a name="sequence"><div id="component">
<a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">sequence</h1>
<BR><BR>
            This object represents an ordered sequence of items, each item is 
            associated with an integer value. The items are numbered from 0 to the number of items in the 
            sequence minus 1. 
         <BR><BR><b>Specification: </b><a href="dlib/sequence/sequence_kernel_abstract.h.html">dlib/sequence/sequence_kernel_abstract.h</a><BR><B>File to include: </B><a href="dlib/sequence.h.html">dlib/sequence.h</a><BR><BR><B>Implementations:</B><blockquote>
<a href="dlib/sequence/sequence_kernel_1.h.html">sequence_kernel_1</a>:
                  <br> 
                  This is implemented as an AVL binary search tree.  
                  Accessing(or adding or removing) an element always takes O(log n) time.  
 It uses the <a href="other.html#memory_manager">memory_manager</a> for all memory allocations. 
               <div id="typedefs"><table CELLSPACING="0" CELLPADDING="0" bgcolor="white">
<tr>
<td bgcolor="#E3E3E3" valign="top"><div id="tdn">kernel_1a</div></td>
<td width="100%" bgcolor="#E3E3E3">is a typedef for sequence_kernel_1</td>
</tr>
<tr>
<td valign="top"><div id="tdn">kernel_1a_c</div></td>
<td width="100%"> 
                  is a typedef for kernel_1a that checks its preconditions.             
                  </td>
</tr>
</table></div>
</blockquote>
<blockquote>
<a href="dlib/sequence/sequence_kernel_2.h.html">sequence_kernel_2</a>:
                  <br> 
                  This implementation is done using a doubly linked list in the shape of a ring.  
                  It will remember the last element accessed(or added or removed) and give O(1) 
                  access time to the elements just left and right of it.  Aside from that, 
                  accessing(or adding or removing) a random element will take O(n) and in the worst 
                  case it will take time proportional to the size of the sequence/2.  
      <p>
                     It does not use the 
                     <a href="other.html#memory_manager">memory_manager</a> at all. 
      </p>

               <div id="typedefs"><table CELLSPACING="0" CELLPADDING="0" bgcolor="white">
<tr>
<td bgcolor="#E3E3E3" valign="top"><div id="tdn">kernel_2a</div></td>
<td width="100%" bgcolor="#E3E3E3">is a typedef for sequence_kernel_2</td>
</tr>
<tr>
<td valign="top"><div id="tdn">kernel_2a_c</div></td>
<td width="100%"> 
                  is a typedef for kernel_2a that checks its preconditions.             
                  </td>
</tr>
</table></div>
</blockquote>
<center>
<HR align="center">
<h2>Extensions to sequence</h2>
</center>
<BR><a name="sequence_compare"><B><font size="4">sequence_compare:</font></B></a><Br> 
                  This extension gives sequences the ability to compare themselves using 
                  operator&lt; and operator==.  Thus they can be used in the other container classes 
                  that require this ability. (maps, sets, etc...)
               <BR><BR><b>Specification: </b><a href="dlib/sequence/sequence_compare_abstract.h.html">dlib/sequence/sequence_compare_abstract.h</a><BR><BR><B>Implementations:</B><blockquote>
<a href="dlib/sequence/sequence_compare_1.h.html">sequence_compare_1</a>:
                  <br> 
                        The implementation is obvious.  Click on the sequence_compare_1 link if you want to see.                       
                     <div id="typedefs"><table CELLSPACING="0" CELLPADDING="0" bgcolor="white">
<tr>
<td bgcolor="#E3E3E3" valign="top"><div id="tdn">compare_1a</div></td>
<td width="100%" bgcolor="#E3E3E3">is a typedef for sequence_kernel_1a extended by sequence_compare_1</td>
</tr>
<tr>
<td valign="top"><div id="tdn">compare_1a_c</div></td>
<td width="100%"> 
                  is a typedef for compare_1a that checks its preconditions.             
                  </td>
</tr>
<tr>
<td bgcolor="#E3E3E3" valign="top"><div id="tdn">compare_1b</div></td>
<td width="100%" bgcolor="#E3E3E3">is a typedef for sequence_kernel_2a extended by sequence_compare_1</td>
</tr>
<tr>
<td valign="top"><div id="tdn">compare_1b_c</div></td>
<td width="100%"> 
                  is a typedef for compare_1b that checks its preconditions.             
                  </td>
</tr>
</table></div>
</blockquote>
<HR width="20%" align="left">
<BR><a name="sequence_sort"><B><font size="4">sequence_sort:</font></B></a><Br> 
                  This extension gives a sequence the ability to sort its contents.
               <BR><BR><b>Specification: </b><a href="dlib/sequence/sequence_sort_abstract.h.html">dlib/sequence/sequence_sort_abstract.h</a><BR><BR><B>Implementations:</B><blockquote>
<a href="dlib/sequence/sequence_sort_1.h.html">sequence_sort_1</a>:
                  <br> 
                        This is a version of the QuickSort algorithm and it sorts sequences of less 
                        than 30 elements with a selection sort.  This implementation is fastest when 
                        used with sequence_kernel_2 and fairly slow when used with sequence_kernel_1                       
                     <div id="typedefs"><table CELLSPACING="0" CELLPADDING="0" bgcolor="white">
<tr>
<td bgcolor="#E3E3E3" valign="top"><div id="tdn">sort_1a</div></td>
<td width="100%" bgcolor="#E3E3E3">is a typedef for sequence_kernel_2a extended by sequence_sort_1</td>
</tr>
<tr>
<td valign="top"><div id="tdn">sort_1a_c</div></td>
<td width="100%"> 
                  is a typedef for sort_1a that checks its preconditions.             
                  </td>
</tr>
</table></div>
</blockquote>
<blockquote>
<a href="dlib/sequence/sequence_sort_2.h.html">sequence_sort_2</a>:
                  <br> 
                        This is a version of the QuickSort algorithm.  This implementation of sort is 
                        the best to use with sequence_kernel_1 objects but gives extremely poor performance 
                        with sequence_kernel_2 objects.
                     <div id="typedefs"><table CELLSPACING="0" CELLPADDING="0" bgcolor="white">
<tr>
<td bgcolor="#E3E3E3" valign="top"><div id="tdn">sort_2a</div></td>
<td width="100%" bgcolor="#E3E3E3">is a typedef for sequence_kernel_1a extended by sequence_sort_2</td>
</tr>
<tr>
<td valign="top"><div id="tdn">sort_2a_c</div></td>
<td width="100%"> 
                  is a typedef for sort_2a that checks its preconditions.             
                  </td>
</tr>
</table></div>
</blockquote>
<center></center>
</div></a><a name="set"><div id="component">
<a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">set</h1>
<BR><BR>
            This object represents an unordered and unaddressed collection of unique items. 
         <BR><BR><b>Specification: </b><a href="dlib/set/set_kernel_abstract.h.html">dlib/set/set_kernel_abstract.h</a><BR><B>File to include: </B><a href="dlib/set.h.html">dlib/set.h</a><BR><BR><B>Implementations:</B><blockquote>
<a href="dlib/set/set_kernel_1.h.html">set_kernel_1</a>:
                  <br> 
                  This is implemented using the <a href="#binary_search_tree">binary_search_tree</a> component.   It uses the 
        <a href="other.html#memory_manager">memory_manager</a> for all memory allocations.

               <div id="typedefs"><table CELLSPACING="0" CELLPADDING="0" bgcolor="white">
<tr>
<td bgcolor="#E3E3E3" valign="top"><div id="tdn">kernel_1a</div></td>
<td width="100%" bgcolor="#E3E3E3">is a typedef for set_kernel_1 that uses binary_search_tree_kernel_1</td>
</tr>
<tr>
<td valign="top"><div id="tdn">kernel_1a_c</div></td>
<td width="100%"> 
                  is a typedef for kernel_1a that checks its preconditions.             
                  </td>
</tr>
<tr>
<td bgcolor="#E3E3E3" valign="top"><div id="tdn">kernel_1b</div></td>
<td width="100%" bgcolor="#E3E3E3">is a typedef for set_kernel_1 that uses binary_search_tree_kernel_2</td>
</tr>
<tr>
<td valign="top"><div id="tdn">kernel_1b_c</div></td>
<td width="100%"> 
                  is a typedef for kernel_1b that checks its preconditions.             
                  </td>
</tr>
</table></div>
</blockquote>
<center>
<HR align="center">
<h2>Extensions to set</h2>
</center>
<BR><a name="set_compare"><B><font size="4">set_compare:</font></B></a><Br> 
                  This extension gives sets the ability to compare themselves using operator&lt; and 
                  operator==.  Thus they can be used in the other container classes that require 
                  this ability. (maps, sets, etc...)
               <BR><BR><b>Specification: </b><a href="dlib/set/set_compare_abstract.h.html">dlib/set/set_compare_abstract.h</a><BR><BR><B>Implementations:</B><blockquote>
<a href="dlib/set/set_compare_1.h.html">set_compare_1</a>:
                  <br> 
                        The implementation is obvious.  Click on the set_compare_1 link if you want to see.                      
                     <div id="typedefs"><table CELLSPACING="0" CELLPADDING="0" bgcolor="white">
<tr>
<td bgcolor="#E3E3E3" valign="top"><div id="tdn">compare_1a</div></td>
<td width="100%" bgcolor="#E3E3E3">is a typedef for set_kernel_1a extended by set_compare_1</td>
</tr>
<tr>
<td valign="top"><div id="tdn">compare_1a_c</div></td>
<td width="100%"> 
                  is a typedef for compare_1a that checks its preconditions.             
                  </td>
</tr>
<tr>
<td bgcolor="#E3E3E3" valign="top"><div id="tdn">compare_1b</div></td>
<td width="100%" bgcolor="#E3E3E3">is a typedef for set_kernel_1b extended by set_compare_1</td>
</tr>
<tr>
<td valign="top"><div id="tdn">compare_1b_c</div></td>
<td width="100%"> 
                  is a typedef for compare_1b that checks its preconditions.             
                  </td>
</tr>
</table></div>
</blockquote>
<center></center>
</div></a><a name="shared_ptr"><div id="component">
<a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">shared_ptr</h1>
<BR><BR>
            <p>
                This object represents a reference counted smart pointer.  Each shared_ptr
                contains a pointer to some object and when the last shared_ptr that points
                to the object is destructed or reset() then the object is guaranteed to be 
                deleted.
            </p>

            <p>
                This is an implementation of the std::tr1::shared_ptr template from the 
                document ISO/IEC PDTR 19768, Proposed Draft Technical Report on C++
                Library Extensions.  The only deviation from that document is that this 
                shared_ptr is declared inside the dlib namespace rather than std::tr1.
            </p>
         <BR><BR><b>Specification: </b><a href="dlib/smart_pointers/shared_ptr_abstract.h.html">dlib/smart_pointers/shared_ptr_abstract.h</a><BR><B>File to include: </B><a href="dlib/smart_pointers.h.html">dlib/smart_pointers.h</a><br><br><center></center>
</div></a><a name="shared_ptr_thread_safe"><div id="component">
<a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">shared_ptr_thread_safe</h1>
<BR><BR>
            <p>
                This object represents a reference counted smart pointer just like 
                <a href="#shared_ptr">shared_ptr</a> except that it is threadsafe.
            </p>
         <BR><BR><b>Specification: </b><a href="dlib/smart_pointers/shared_ptr_thread_safe_abstract.h.html">dlib/smart_pointers/shared_ptr_thread_safe_abstract.h</a><BR><B>File to include: </B><a href="dlib/smart_pointers.h.html">dlib/smart_pointers.h</a><br><br><center></center>
</div></a><a name="sliding_buffer"><div id="component">
<a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">sliding_buffer</h1>
<BR><BR>
            This object represents an array with the ability to rotate its contents
                        left or right. 
         <BR><BR><b>Specification: </b><a href="dlib/sliding_buffer/sliding_buffer_kernel_abstract.h.html">dlib/sliding_buffer/sliding_buffer_kernel_abstract.h</a><BR><B>File to include: </B><a href="dlib/sliding_buffer.h.html">dlib/sliding_buffer.h</a><BR><BR><B>Implementations:</B><blockquote>
<a href="dlib/sliding_buffer/sliding_buffer_kernel_1.h.html">sliding_buffer_kernel_1</a>:
                  <br> 
                  This object is implemented using a C style array in the obvious way.  See the code for details. 
               <div id="typedefs"><table CELLSPACING="0" CELLPADDING="0" bgcolor="white">
<tr>
<td bgcolor="#E3E3E3" valign="top"><div id="tdn">kernel_1a</div></td>
<td width="100%" bgcolor="#E3E3E3">is a typedef for sliding_buffer_kernel_1</td>
</tr>
<tr>
<td valign="top"><div id="tdn">kernel_1a_c</div></td>
<td width="100%"> 
                  is a typedef for kernel_1a that checks its preconditions.             
                  </td>
</tr>
</table></div>
</blockquote>
<center></center>
</div></a><a name="stack"><div id="component">
<a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">stack</h1>
<BR><BR>
            This object represents a last in first out stack. 
         <BR><BR><b>Specification: </b><a href="dlib/stack/stack_kernel_abstract.h.html">dlib/stack/stack_kernel_abstract.h</a><BR><B>File to include: </B><a href="dlib/stack.h.html">dlib/stack.h</a><BR><BR><B>Implementations:</B><blockquote>
<a href="dlib/stack/stack_kernel_1.h.html">stack_kernel_1</a>:
                  <br> 
                  This implementation is done in the obvious way using a singly linked list.  It uses the 
        <a href="other.html#memory_manager">memory_manager</a> for all memory allocations. 

               <div id="typedefs"><table CELLSPACING="0" CELLPADDING="0" bgcolor="white">
<tr>
<td bgcolor="#E3E3E3" valign="top"><div id="tdn">kernel_1a</div></td>
<td width="100%" bgcolor="#E3E3E3">is a typedef for stack_kernel_1</td>
</tr>
<tr>
<td valign="top"><div id="tdn">kernel_1a_c</div></td>
<td width="100%"> 
                  is a typedef for kernel_1a that checks its preconditions.             
                  </td>
</tr>
</table></div>
</blockquote>
<center></center>
</div></a><a name="static_map"><div id="component">
<a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">static_map</h1>
<BR><BR>
            This object represents a mapping of items of type domain onto items of type range. 
            The difference between this object and the normal <a href="#map">map</a> object is that it does not support adding
            or removing individual objects from itself.  This allows implementations to focus on using less memory and 
            achieving faster searching. 
         <BR><BR><b>Specification: </b><a href="dlib/static_map/static_map_kernel_abstract.h.html">dlib/static_map/static_map_kernel_abstract.h</a><BR><B>File to include: </B><a href="dlib/static_map.h.html">dlib/static_map.h</a><BR><BR><B>Implementations:</B><blockquote>
<a href="dlib/static_map/static_map_kernel_1.h.html">static_map_kernel_1</a>:
                  <br> 
                  This implementation is just a sorted array which can be searched using a binary search.  
               <div id="typedefs"><table CELLSPACING="0" CELLPADDING="0" bgcolor="white">
<tr>
<td bgcolor="#E3E3E3" valign="top"><div id="tdn">kernel_1a</div></td>
<td width="100%" bgcolor="#E3E3E3">is a typedef for static_map_kernel_1</td>
</tr>
<tr>
<td valign="top"><div id="tdn">kernel_1a_c</div></td>
<td width="100%"> 
                  is a typedef for kernel_1a that checks its preconditions.             
                  </td>
</tr>
</table></div>
</blockquote>
<center></center>
</div></a><a name="static_set"><div id="component">
<a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">static_set</h1>
<BR><BR>
            This object represents an unordered and unaddressed collection of items. 
            The difference between this object and the normal <a href="#set">set</a> object is that it does not support adding
            or removing individual objects from itself.  This allows implementations to focus on using less memory and 
            achieving faster searching. 
         <BR><BR><b>Specification: </b><a href="dlib/static_set/static_set_kernel_abstract.h.html">dlib/static_set/static_set_kernel_abstract.h</a><BR><B>File to include: </B><a href="dlib/static_set.h.html">dlib/static_set.h</a><BR><b>Code Examples: </b><a href="dir_nav_ex.cpp.html">1</a><BR><BR><B>Implementations:</B><blockquote>
<a href="dlib/static_set/static_set_kernel_1.h.html">static_set_kernel_1</a>:
                  <br> 
                  This implementation is just a sorted array which can be searched using a binary search.  
               <div id="typedefs"><table CELLSPACING="0" CELLPADDING="0" bgcolor="white">
<tr>
<td bgcolor="#E3E3E3" valign="top"><div id="tdn">kernel_1a</div></td>
<td width="100%" bgcolor="#E3E3E3">is a typedef for static_set_kernel_1</td>
</tr>
<tr>
<td valign="top"><div id="tdn">kernel_1a_c</div></td>
<td width="100%"> 
                  is a typedef for kernel_1a that checks its preconditions.             
                  </td>
</tr>
</table></div>
</blockquote>
<center>
<HR align="center">
<h2>Extensions to static_set</h2>
</center>
<BR><a name="static_set_compare"><B><font size="4">static_set_compare:</font></B></a><Br> 
                  This extension gives static_sets the ability to compare themselves using operator&lt; and 
                  operator==.  Thus they can be used in the other container classes that require 
                  this ability. (maps, static_sets, etc...)
               <BR><BR><b>Specification: </b><a href="dlib/static_set/static_set_compare_abstract.h.html">dlib/static_set/static_set_compare_abstract.h</a><BR><BR><B>Implementations:</B><blockquote>
<a href="dlib/static_set/static_set_compare_1.h.html">static_set_compare_1</a>:
                  <br> 
                        The implementation is obvious.  Click on the static_set_compare_1 link if you want to see.                        
                     <div id="typedefs"><table CELLSPACING="0" CELLPADDING="0" bgcolor="white">
<tr>
<td bgcolor="#E3E3E3" valign="top"><div id="tdn">compare_1a</div></td>
<td width="100%" bgcolor="#E3E3E3">is a typedef for static_set_kernel_1a extended by static_set_compare_1</td>
</tr>
<tr>
<td valign="top"><div id="tdn">compare_1a_c</div></td>
<td width="100%"> 
                  is a typedef for compare_1a that checks its preconditions.             
                  </td>
</tr>
</table></div>
</blockquote>
<center></center>
</div></a><a name="std_vector_c"><div id="component">
<a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">std_vector_c</h1>
<BR><BR>
            This object is a simple wrapper around the std::vector object.  It 
            provides an identical interface but also checks the preconditions of
            each member function.  That is, if you violate a requires
            clause the dlib::fatal_error exception is thrown. 
         <BR><BR><b>Specification: </b><a href="dlib/stl_checked/std_vector_c_abstract.h.html#std_vector_c">dlib/stl_checked/std_vector_c_abstract.h</a><BR><B>File to include: </B><a href="dlib/stl_checked.h.html">dlib/stl_checked.h</a><br><br><center></center>
</div></a><a name="tuple"><div id="component">
<a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">tuple</h1>
<BR><BR>
                This is an implementation of a very simple templated container object.
                It contains between 0 and 31 objects where each object is listed
                explicity in the tuple's template arguments.   

            <p>
               Note that there is only one implementation of this object so there aren't any
               different kernels to choose from when you create instances of the matrix object.  
               So for example, you
               could declare a tuple of 3 ints using the following statement: 
               <tt>dlib::tuple&lt;int,int,int&gt; t;</tt>  
            </p>
         <BR><BR><b>Specification: </b><a href="dlib/tuple/tuple_abstract.h.html">dlib/tuple/tuple_abstract.h</a><BR><B>File to include: </B><a href="dlib/tuple.h.html">dlib/tuple.h</a><br><br><center></center>
</div></a><a name="weak_ptr"><div id="component">
<a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">weak_ptr</h1>
<BR><BR>
            <p>
                The weak_ptr class template stores a weak reference to an object that is 
                already managed by a shared_ptr. To access the object, a weak_ptr can 
                be converted to a shared_ptr using the member function lock().  
            </p>

            <p>
                This is an implementation of the std::tr1::weak_ptr template from the 
                document ISO/IEC PDTR 19768, Proposed Draft Technical Report on C++
                Library Extensions.  The only deviation from that document is that this 
                shared_ptr is declared inside the dlib namespace rather than std::tr1.
            </p>
         <BR><BR><b>Specification: </b><a href="dlib/smart_pointers/weak_ptr_abstract.h.html">dlib/smart_pointers/weak_ptr_abstract.h</a><BR><B>File to include: </B><a href="dlib/smart_pointers.h.html">dlib/smart_pointers.h</a><br><br><center></center>
</div></a>
</div>
</body>
</html>
